%% Comparison between internal and external definition of seq

Def seq L t.
Def seq L (atom A) :- member A L.
Def seq L (and A B) :- seq L A, seq L B.
Def seq L (A => B) :- seq (A :: L) B.
Def seq L (pi G) :- nabla x, seq L (G x).
Def seq L (sigma G) :- seq L (G X).
Def seq L (atom A) :- prog A B, seq L B.

Theorem external : forall S T,
  seq nil (pi x\ p x S => pi y\ p y T => atom (p x T)) -> S = T.
intros.
case H1.
case H2.
case H3.
case H4.
case H5.
case H6.
case H7.
  case H8. case H9.
    search.
    case H10.
  case H8.

Theorem internal : forall S T,
  {pi x\ p x S => pi y\ p y T => p x T} -> S = T.
intros.
case H1.
case H2.
case H3.
  search.
  case H4.

%% An external version of add.mod/thm
%%
%% The primary difference (besides the extra syntax of "atom") is that
%% for (seq nil P) we have to consider both (member P nil) and
%% (prog P B, seq nil B). Then we have to do case analysis on (prog P B)
%% to unfold the body of P. In the internal version, all of this is
%% contained in one case analysis.

Def prog (nat z) t.
Def prog (nat (s N)) (atom (nat N)).

Def prog (add z N N) t.
Def prog (add (s A) B (s C)) (atom (add A B C)).

Theorem add_base : forall N,
  seq nil (atom (nat N)) -> seq nil (atom (add N z N)).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3. search.

Theorem add_step : forall A B C,
  seq nil (atom (add A B C)) -> seq nil (atom (add A (s B) (s C))).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3. search.

Theorem add_comm : forall A B C, seq nil (atom (nat B)) ->
  seq nil (atom (add A B C)) -> seq nil (atom (add B A C)).
induction on 2. intros. case H2.
  case H3.
  case H3.
    apply add_base to H1. search.
    apply IH to H1 H4. apply add_step to H5. search.


%% A benefit of the external definition of seq is that it allows us to prove
%% meta-theoremas about lambda prolog. But first we need some properties
%% about lists.

Def select (X :: A) X A.
Def select (Y :: A) X (Y :: B) :- select A X B.

Def perm nil nil.
Def perm (X :: A') B :- select B X B', perm A' B'.

Theorem select_member_base : forall X L1 L2,
  select L1 X L2 -> member X L1.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem select_member_step : forall X Y L1 L2,
  select L1 X L2 -> member Y L2 -> member Y L1.
induction on 1. intros. case H1.
  search.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem perm_member : forall X L1 L2,
  member X L1 -> perm L1 L2 -> member X L2.
induction on 2. intros. case H2.
  search.
  case H1.
    apply select_member_base to H3. search.
    apply IH to H5 H4. apply select_member_step to H3 H6. search.

Theorem seq_perm : forall L1 L2 G,
  seq L1 G -> perm L1 L2 -> seq L2 G.
induction on 1. intros. case H1.
  search.
  apply perm_member to H3 H2. search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  apply IH to H3 _. search.
  case H3. apply IH to H4 H2. search.
    skip. % Error the search should succeed
  apply IH to H3 H2. search.
  apply IH to H4 H2. search.

Theorem seq_cut : forall A L G,
  seq (K :: L) G -> seq L (atom K) -> seq L G.
induction on 1. intros. case H1.
  search.
  case H3.
    % Key Case, G=K
    search.
    search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  assert seq (K :: A' :: L) B.
    assert perm (A' :: K :: L) (K :: A' :: L).
      skip. % Why do we need to skip this?
      apply seq_perm to H3 H4. search.
    % We want to apply IH but we can't because we got
    %   seq (A' :: K :: L) B *  and
    %   seq (K :: A' :: L) B    so we were not able to keep the star
    %                           with that lemma... hrm..
    skip.
  case H3. apply IH to H4 H2. search.
    skip. % Error the search should succeed.
  apply IH to H3 H2. search.
  apply IH to H4 H2. search.
