Clean up nominals so that we can generate lists of them at a time.
  Add tests for this in search, case, apply, etc

How to talk about theorems which preserve measures?
  See the seq examples for a use

Change the representation of contexts to something more managable?
  Would need to add operators to fiddle with the context so that the
  cut example could still work. But perhaps there is a benefit to
  making such operations explict since they rely on properties of
  lambda prolog. Actually they are all the same property,
    {L1 |- P} -> (forall X, member X L1 -> member X L2) -> {L2 |- P}
  So maybe a simple change_context (yuck that's long) tactic would
  work. The key thing is that we can still expand contexts easily
  during typical inductions.

Case with nabla in the head
  Allow more raisings
  Allow for permutations of nabla variables
  Figure out how to name new nabla variables

Search with nabla in the head
  Allow more raising (maybe not needed if we use rigid definitions)
  Allow for permutations of nabla variables
  Figure out how to name new nabla variables

Add tests for raising in apply?
  How are we going to handle raising in apply?
  Add test for apply to nabla variables

Future
======

Should meta_right_unify track used variables?

Can we use a more declarative approach to help with nabla variables?
  So the user picks the names?
  Could this also work with imp-L?

Clean up similarities between replace_metaterm_vars and normalize_binders

Make a seperate type for (id * term) list?

Have "unfold" do the work of "split" ?

Make a reflist extension like in extlib?

Find a way of handling undo state so that I don't have to remember to
  call it each time I start a tactic

Unify/Search bug if last clause of step is moved first in norm.mod
  
Abstract out List.flatten (List.map collect_terms ...) ?

Support "when T = abs S R." or "when T = abs _ _". in order to
distinguish cases. Try using this in pcf example?

Support tac1;tac2 where tac2 applies to all subgoals of tac1

How to deal with logic variables at the top level
  We need to remember their bindings

Allow naming of hypotheses and then get rid of hyps during case

Add an apply tactic that works backwards like in coq?
  If so, clean up normal2.thm where we assert

Check that TODO in unify.ml is sound

Add more bedwyr style searching?
  Watch timestamps more closely?
  Change not (try_left_unify ...) so unification errors (not failures)
    do not result in success

Display new hypotheses in future subgoals? (subgoal 2 is : {...} -> ...)
  
Do we have to consider logic variables in the context during search?

Fix timestamp bug in unify that David has a test for


Larger or longer term issues
============================
Remove duplication between case analysis and searching?

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

Add a show_lemmas command
Add an abort command

Add warning if using a capital name without it appearing in forall
  e.g. forall A, {rev A B} -> {rev B A}. should warn about B.

Can we represent /\ and \/ using,
  a \/ b := a.
  a \/ b := b.

  a /\ b := a, b.

  What would this mean in the logic?
    Here a and b range over predicates insetad of terms

What is the relationship between meta-level predicates without
implication and object-level predicates without implication?
