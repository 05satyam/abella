Unfold on inductive definition should remove the inductive
constraints. But why? Does something similar happen for case analysis
on the left with induction?

Before releasing with coinduction
  Add some description of co-induction to reference guide or new
    walkthrough?
  Add new examples to reference-guide
  Add to release notes
  Send release information to Alwen, Dale, Gopalan, David, Zach

Future
======
Get definitions to work with multiple nablas?

Search and case should be smart about looking up definitions

split should work on n-ary conjunctions

Clean up case-analysis tests so they are easy to read and write like
the search tests?

Clean up similarities between replace_metaterm_vars and normalize_binders

Find a way of handling undo state so that I don't have to remember to
  call it each time I start a tactic

Change tactics to be first class and implement tacticals?
  Allow naming of hypotheses
  Support tac1;tac2 where tac2 applies to all subgoals of tac1

Add an apply tactic that works backwards like in coq?

Do we have to consider logic variables in the context during search?

New syntax for inductive and coinductive definitions?
  Allow for empty predicate definitions
  Allow for opaque predicate definitions

Larger or longer term issues
============================
Implement a robust auto tactic which uses search but also goes
underneath implies and forall. Should backchain on hyps and lemmas
too.

Allow apply with hyps like
  forall X T, member (of X T) L -> forall T', {L |- of X T'} -> T =
  T'.
  How to handle nested nablas then?
  Get David's proof to go through properly

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

Add a show_lemmas command

Can we represent /\ and \/ using,
  a \/ b := a.
  a \/ b := b.

  a /\ b := a, b.

  What would this mean in the logic?
    Here a and b range over predicates insetad of terms

What is the relationship between meta-level predicates without
implication and object-level predicates without implication?

How to deal with logic variables at the top level
  We need to remember their bindings
  Would also require fixing our issues with timestamps
  This might be best to leave unsupported
  Fix timestamp bug in unify that David has a test for
  Would also search underneath forall
