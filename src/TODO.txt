Add clause_support to case analysis to prevent conflicts during raising

Fix capture bug when raising over a new nominal causes an existing
bound nabla variable to capture the new one.

Add tests for raising in apply?
  How are we going to handle raising in apply?
  Add test for apply to nabla variables

Clean up case-analysis tests so they are easy to read and write like
the search tests?

How to talk about theorems which preserve measures?
  See the seq examples for a use

Future
======

Should meta_right_unify track used variables?

Can we use a more declarative approach to help with nabla variables?
  So the user picks the names?
  Could this also work with imp-L?

Clean up similarities between replace_metaterm_vars and normalize_binders

Make a seperate type for (id * term) list?

Have "unfold" do the work of "split" ?
  Support unfold on lambda-prolog predicates
  Support unfold for nabla in the head

Make a reflist extension like in extlib?

Find a way of handling undo state so that I don't have to remember to
  call it each time I start a tactic

Abstract out List.flatten (List.map collect_terms ...) ?

Support "when T = abs S R." or "when T = abs _ _". in order to
distinguish cases. Try using this in pcf example?

Support tac1;tac2 where tac2 applies to all subgoals of tac1

Allow naming of hypotheses

Add an apply tactic that works backwards like in coq?

Check that TODO in unify.ml is sound

Display new hypotheses in future subgoals? (subgoal 2 is : {...} -> ...)
  
Do we have to consider logic variables in the context during search?


Larger or longer term issues
============================
Remove duplication between case analysis and searching?

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

Add a show_lemmas command

Can we represent /\ and \/ using,
  a \/ b := a.
  a \/ b := b.

  a /\ b := a, b.

  What would this mean in the logic?
    Here a and b range over predicates insetad of terms

What is the relationship between meta-level predicates without
implication and object-level predicates without implication?

How to deal with logic variables at the top level
  We need to remember their bindings
  Would also require fixing our issues with timestamps
  This might be best to leave unsupported
  Fix timestamp bug in unify that David has a test for
