Case with nabla in the head
  Allow more raisings
  Allow for permutations of nabla variables
  Figure out how to name new nabla variables

Search with nabla in the head
  Allow more raising
  Actually perform the raising
  Allow for permutations of nabla variables
  Figure out how to name new nabla variables

Add tests for raising in apply?
  How are we going to handle raising in apply?
  Add test for apply to nabla variables

Future
======

Make a seperate type for (id * term) list?

Have "unfold" do the work of "split" ?

How to deal with forall R, X = R when X gets bound to R?
  How do we know to rename to avoid capture?
    Maybe normalize the term and look for constants (not eigen) with same
     name as quantifier variables? Kind of a hack...
     Maybe introduce a new variable type : bound
  If fixed, clean up names for type_uniq and norm

Make a reflist extension like in extlib?

Find a way of handling undo state so that I don't have to remember to
  call it each time I start a tactic

Unify/Search bug if last clause of step is moved first in norm.mod
  
Abstract out List.flatten (List.map collect_terms ...) ?

Support tac1;tac2 where tac2 applies to all subgoals of tac1

How to deal with logic variables at the top level
  We need to remember their bindings

Abstract out { context = List.map f context ; term = f term }

Allow naming of hypotheses and then get rid of hyps during case

Add an apply tactic that works backwards like in coq?
  If so, clean up normal2.thm where we assert

Check that TODO in unify.ml is sound

Add more bedwyr style searching?
  Watch timestamps more closely?
  Change not (try_left_unify ...) so unification errors (not failures)
    do not result in success

Display new hypotheses in future subgoals? (subgoal 2 is : {...} -> ...)
  
Do we have to consider logic variables in the context during search?

Add unification over lppterms?
  If so then simplify search, case, and apply

Fix timestamp bug in unify that David has a test for

Support induction on linc predicates by assuming an implicit natural
  number argument. Then replace axioms with theorems in examples.

Larger or longer term issues
============================
Remove duplication between case analysis and searching?

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

Add a show_lemmas command
Add an abort command

Add warning if using a capital name without it appearing in forall
  e.g. forall A, {rev A B} -> {rev B A}. should warn about B.

Can we represent /\ and \/ using,
  a \/ b := a.
  a \/ b := b.

  a /\ b := a, b.

  What would this mean in the logic?
    Here a and b range over predicates insetad of terms
