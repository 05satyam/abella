Examples
========
System F - can we quantify over logical relations?
Bohm's theorem from Barendregt
Separation theorems from Barendregt
Lustre equation reordering
Lazy lambda calculus by Abramsky

Document in next release
========================
Hierarchical numbering for subgoals
Set command (usable in proofs) and the subgoal option

Future
======
New syntax for inductive and coinductive definitions?
  Allow for empty predicate definitions? (can define :- false)
  Require used definitions to be defined
  Allow mutual recursion between coinductive and inductive but not both

Search and case should be smart about looking up definitions

Coinduction followed by induction would allow hypotheses with @ on
them. What does these mean? Should they be allowed? prevented?
ignored?

What about induction followed by coinduction?

Clean up case-analysis tests so they are easy to read and write like
the search tests?

Clean up similarities between replace_metaterm_vars and normalize_binders

Find a way of handling undo state so that I don't have to remember to
  call it each time I start a tactic


Larger or longer term issues
============================
Implement a robust auto tactic which uses search but also goes
underneath implies and forall. Should backchain on hyps and lemmas
too. To make it faster, perhaps you could specify the hyps and lemmas
that are relevant (like Isabelle's Isar mode).

Allow apply with hyps like
  forall X T, member (of X T) L -> forall T', {L |- of X T'} -> T =
  T'.
  How to handle nested nablas then?
  Get David's proof to go through properly

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

How to deal with logic variables at the top level
  We need to remember their bindings
  Would also require fixing our issues with timestamps
  This might be best to leave unsupported
  Fix timestamp bug in unify that David has a test for
  Would also search underneath forall

In STLC, this theorem shows a real pain in not having types
  Theorem str : forall L E T A, nabla x,
    ctx L -> {L, of x A |- of E T} -> {L |- of E T}.

