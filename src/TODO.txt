Document in next release
========================
apply should no longer require "dummy nominals" when nabla bound
  variables in a lemma are not used
Fixed some issues with subgoal numbering
Added search cut tactic
Optimized handling of state, roughly 70% speed increase on examples
  (test again before release with direct version to version
  comparison)
Search on goals with "exists" now make use of all nominals in a proof
  rather than just those in the goal.

Later
=====
Add a C-c C-a command to emacs mode which aborts the current proof and
goes back to the start of the theorem.

Disallow constants with name n[0-9]+

Allow delcarations about which types are nominal?
  But which ones are automatically nominal?

Polymorphism? Type constructors?
  Issues when using 'apply' and metavariables

Future
======
Change context handling to use explicit tail variable

Change def to use (nabla_bindings, head_term, body_metaterm) rather
  than two metaterms

Allow 'search with ...' and use backchain on the provided arguments.
  Perhaps a full-fledged auto tactic which would do some limited left rules?

Allow for tacticals
  This requires reworking many things.
  How is tactic failure propogated through tacticals?

From Todd Wilson: Every time I've used "apply .. with .." so far, the
  with clause has been an identity substitution, e.g., "with T0=T0,
  M0=M0". Would it be reasonable to default to this instead of giving
  an error message for missing variables?

Clean up case-analysis tests so they are easy to read and write like
the search tests?

Clean up similarities between replace_metaterm_vars and normalize_binders


Examples
========
System F - can we quantify over logical relations?
Bohm's theorem from Barendregt
Separation theorems from Barendregt
Lustre equation reordering
Lazy lambda calculus by Abramsky


Larger or longer term issues
============================
Implement a robust auto tactic which uses search but also goes
underneath implies and forall. Should backchain on hyps and lemmas
too. To make it faster, perhaps you could specify the hyps and lemmas
that are relevant (like Isabelle's Isar mode).

Allow apply with hyps like
  forall X T, member (of X T) L -> forall T', {L |- of X T'} -> T =
  T'.
  How to handle nested nablas then?
  Get David's proof to go through properly

Use type information from sig files?

Change OMakefile so exceptions print full stack trace? Is there a way
  to integrate this with OUnit?

How to deal with logic variables at the top level
  We need to remember their bindings
  Would also require fixing our issues with timestamps
  This might be best to leave unsupported
  Fix timestamp bug in unify that David has a test for
  Would also search underneath forall

In STLC, this theorem shows a real pain in not having types
  Theorem str : forall L E T A, nabla x,
    ctx L -> {L, of x A |- of E T} -> {L |- of E T}.

