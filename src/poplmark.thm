%% Start generic section

Def nabla x, nominal x.
Def nabla x, fresh x E.

Theorem fresh_tail : forall X A L,
  fresh X (A :: L) -> fresh X L.
intros. case H1. search.

Theorem member_fresh : forall X L E,
  member E L -> fresh X L -> fresh X E.
induction on 1. intros. case H1.
  case H2. search.
  apply fresh_tail to H2. apply IH to H3 H4. search.

%% End generic section

Def ctx nil.
Def ctx (bound X U :: L) :- fresh X L, ctx L.

Def ty L top.
Def ty L X :- member (bound X U) L.
Def ty L (arrow T1 T2) :- ty L T1, ty L T2.
Def ty L (all T1 T2) :- ty L T1, (nabla x, ty (bound x T1 :: L) (T2 x)).

Theorem sub_refl : forall L T,
  ty L T -> {L |- sub T T}.
induction on 1. intros. case H1.
  search.
  search.
  apply IH to H2. apply IH to H3. search.
  apply IH to H2. case H3. apply IH to H5. search.

Theorem no_ctx_sub : forall S T L,
  ctx L -> member (sub S T) L -> false.
induction on 1. intros. case H1.
  case H2.
  case H2.
    apply IH to H4 H5. search.

Theorem ctx_nominal : forall L X U,
  ctx L -> member (bound X U) L -> nominal X.
induction on 1. intros. case H1.
  case H2.
  case H2.
    case H3. search.
    apply IH to H4 H5. search.

Theorem permute_weaken : forall L1 L2 S T,
  {L1 |- sub S T} -> (forall E, member E L1 -> member E L2) -> {L2 |- sub S T}.
induction on 1. intros. case H1.
  apply H2 to H3. search.
  search.
  case H3. apply H2 to H4. search.
  case H3. apply H2 to H5. search.
    apply IH to H4 H2. search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  %% Would be nice to use nominal constants directly...
  assert nabla x,
    forall E, member E (bound x T1 :: L1) -> member E (bound x T1 :: L2).
    intros. case H5.
      search.
      apply H2 to H6. search.
    case H5. apply IH to H4 H6.
      apply IH to H3 H2.
        search.
        
    
    


