%% Start generic section

Def nabla x, nominal x.
Def nabla x, fresh x E.

Theorem fresh_tail : forall X A L,
  fresh X (A :: L) -> fresh X L.
intros. case H1. search.

Theorem member_fresh : forall X L E,
  member E L -> fresh X L -> fresh X E.
induction on 1. intros. case H1.
  case H2. search.
  apply fresh_tail to H2. apply IH to H3 H4. search.

%% End generic section

Def ctx nil.
Def ctx (bound X U :: L) :- fresh X L, ctx L.

Def ty L top.
Def ty L X :- member (bound X U) L.
Def ty L (arrow T1 T2) :- ty L T1, ty L T2.
Def ty L (all T1 T2) :- ty L T1, (nabla x, ty (bound x T1 :: L) (T2 x)).

Theorem sub_refl : forall L T,
  ty L T -> {L |- sub T T}.
induction on 1. intros. case H1.
  search.
  search.
  apply IH to H2. apply IH to H3. search.
  apply IH to H2. case H3. apply IH to H5. search.

Theorem ctx_no_sub : forall S T L,
  ctx L -> member (sub S T) L -> false.
induction on 1. intros. case H1.
  case H2.
  case H2.
    apply IH to H4 H5. search.

Theorem ctx_nominal : forall L X U,
  ctx L -> member (bound X U) L -> nominal X.
induction on 1. intros. case H1.
  case H2.
  case H2.
    case H3. search.
    apply IH to H4 H5. search.

Theorem ctx_nominal2 : forall L X U,
  ctx L -> {L |- bound X U} -> nominal X.
intros. case H2. apply ctx_nominal to H1 H3. search.

%% This would be a nice general theorem to prove, but it does not work.
%% The P here ends up quantifying over any lambda prolog predicate introduced
%% so far, rather than being general. Perhaps if we changed our definition
%% of {L |- P} it would be possible. See the seq example for more information.
%%
%% Theorem permute_weaken_general : forall L1 L2 P,
%%  {L1 |- P} -> (forall E, member E L1 -> member E L2) -> {L2 |- P}.

Theorem permute_weaken : forall L1 L2 S T,
  {L1 |- sub S T} -> (forall E, member E L1 -> member E L2) -> {L2 |- sub S T}.
induction on 1. intros. case H1.
  apply H2 to H3. search.
  search.
  case H3. apply H2 to H4. search.
  case H3. apply H2 to H5. search.
    apply IH to H4 H2. search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  %% Would be nice to use nominal constants directly...
  assert nabla x,
    forall E, member E (bound x T1 :: L1) -> member E (bound x T1 :: L2).
    intros. case H5.
      search.
      apply H2 to H6. search.
    case H5. apply IH to H4 H6.
      apply IH to H3 H2.
        search.

Theorem sub_top : forall L T,
  ctx L -> {L |- sub top T} -> T = top.
intros. case H2.
  apply ctx_no_sub to H1 H3. case H4.
  search.
  search.
  apply ctx_nominal2 to H1 H3. case H5.

Theorem dual_theorem : forall L Q,
  ctx L -> ty L Q ->
    (forall S T, {L |- sub S Q} -> {L |- sub Q T} -> {L |- sub S T}) /\
    (forall X M N P L',
      (forall E, member E (bound X Q :: L) -> member E L') ->
        {L' |- sub M N} -> {L |- sub P Q} ->
        (forall E, member E L' -> member ???


% Theorem transitivity : forall L Q S T,
%   ctx L -> ty L Q -> {L |- sub S Q} -> {L |- sub Q T} -> {L |- sub S T}.
% induction on 2. induction on 3. intros. case H3.
%   apply ctx_no_sub to H1 H5. case H6.
%   apply sub_top to H1 H4. case H5. search.
%   search.
%   apply IH' to H1 H2 H6 H4. search.
%   case H2.
%     apply ctx_nominal to H1 H7. case H8.
%     case H4.
%       apply ctx_no_sub to H1 H9. case H10.
%       search.
%       apply ctx_nominal2 to H1 H9. case H10.
%       apply ctx_nominal2 to H1 H9. case H11.
%       apply IH to H1 H7 H9 H5. apply IH to H1 H8 H6 H10. search.
%   case H2.
%     apply ctx_nominal to H1 H7. case H8.
%     case H8.
%       case H4.
%         apply ctx_no_sub to H1 H10. case H11.
%         search.
%         apply ctx_nominal2 to H1 H10. case H11.
%         apply ctx_nominal2 to H1 H10. case H12.
%         apply IH to H1 H7 H10 H5.

        
      

    


