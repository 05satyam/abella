%% Tait's logical relations argument for proving normalization for the
%% simply typed lambda calculus. This is based on the presentation in
%% Types and Programming Languages by Pierce.
%% [Work in progress]

%% Conventions:
%% Types: A, B, C
%% Terms: M, N, P, R, V

Def halts M :- exists V, {nstep M V} /\ {value V}.

%% Reduce is the logical relation used to prove normalization.
%% We write the term before the type to match the signature of "of".
%% This definition is not strictly admitted in the logic G due to the use
%% of reduce in a negative context. However, a more fine grained
%% notion of stratification will allow this definition.
Def reduce M top :- {of M top}, halts M.
Def reduce M (arrow A B) :-
  {of M (arrow A B)},
  halts M,
  (forall N, reduce N A -> reduce (app M N) B).

Theorem reduce_halts : forall A M, reduce M A -> halts M.
intros. case H1.
  search.
  search.

Theorem reduce_of : forall A M, reduce M A -> {of M A}.
intros. case H1.
  search.
  search.

Theorem absurd_step_value : forall V M,
  {step V M} -> {value V} -> false.
intros. case H1.
  case H2.
  case H2.
  case H2.

Theorem step_det : forall M N P,
  {step M N} -> {step M P} -> N = P.
induction on 1. intros. case H1.
  case H2.
    apply IH to H3 H4. case H5. search.
    apply absurd_step_value to H3 H4. case H6.
    case H3.
  case H2.
    apply absurd_step_value to H5 H3. case H6.
    apply IH to H4 H6. case H7. search.
    apply absurd_step_value to H4 H5. case H6.
  case H2.
    case H4.
    apply absurd_step_value to H5 H3. case H6.
    search.

Theorem step_nstep : forall M N V,
  {step M N} -> {nstep M V} -> {value V} -> {nstep N V}.
intros. case H2.
  apply absurd_step_value to H1 H3. case H4.
  apply step_det to H1 H4. case H6. search.

Theorem halt_step_forward : forall M N,
  halts M -> {step M N} -> halts N.
intros. case H1. case H3. case H4.
  apply step_nstep to H2 H5 H6. search.

Theorem halt_step_backward : forall M N,
  halts N -> {step M N} -> halts M.
intros. case H1. case H3. case H4.
  %% TODO: why does search not find this?
  assert {nstep M V1}. search.
    search.

Theorem of_step_forward : forall M N A,
  {of M A} -> {step M N} -> {of N A}.
induction on 2. intros. case H2.
  case H1. apply IH to H4 H3. search.
  case H1. apply IH to H6 H4. search.
  case H1. case H4.
    inst H6 with n1 = M1.
      cut H7 with H5. search.

Theorem reduce_step_forward : forall M N A,
  reduce M A -> {step M N} -> reduce N A.
induction on 1. intros. case H1.
  apply of_step_forward to H3 H2.
    apply halt_step_forward to H4 H2.
      search.
  unfold.
    apply of_step_forward to H3 H2. search.
    apply halt_step_forward to H4 H2. search.
    intros. apply H5 to H6.
      apply IH to H7 _. search.

Theorem reduce_step_backward : forall M N A,
  reduce N A -> {step M N} -> {of M A} -> reduce M A.
induction on 1. intros. case H1.
  apply halt_step_backward to H5 H2. search.
  unfold.
    search.
    apply halt_step_backward to H5 H2. search.
    intros. apply H6 to H7.
      apply reduce_of to H7.
        apply IH to H8 _ _. search.

%% Now we need to state the generalize theorem. This will require reasoning
%% about all possible closed instantiations of an open term.

% of_ctx defines the context of "of M A" judgments
Def of_ctx nil.
Def nabla x, of_ctx (of x A :: L) :- of_ctx L.

% Suppose that {L |- of M A} is true. Then M is an open term with nominal
% constants that are listed in L. The judgment "close L M N" holds for all
% closed instantiations N of the nominal constants in M. The key to defining
% this judgment is the use of nabla in the head of a definition which
% extracts a nominal constant from L and M. The definition of "close" then
% substitutes for this nominal constant and continues processing the list L.
Def close nil M M.
Def nabla x, close (of x A :: L) (R x) M :-
  reduce V A, {term V}, close L (R V) M.
% V is not in the head, so it is treated as bound existentially in the body.
% The judgment {term V} asserts that V is a closed term.

Def term_ctx nil.
Def nabla x, term_ctx (term x :: L) :- term_ctx L.

Theorem absurd_member_type_term_ctx : forall L A,
  member (type A) L -> term_ctx L -> false.
induction on 2. intros. case H2.
  case H1.
  case H1. apply IH to H4 H3. case H5.

% Types do not contain nominal constants
Theorem type_ground_ext : forall L A, nabla x,
  term_ctx L -> {L |- type (A x)} -> exists B, A = (x\ B).
induction on 2. intros. case H2.
  apply absurd_member_type_term_ctx to H3 H1. case H4.
  search.
  apply IH to H1 H3. case H5. case H6.
    apply IH to H1 H4. case H7. case H8.
      search.

Theorem type_ground : forall A, nabla x,
  {type (A x)} -> exists B, A = (x\ B).
intros. apply type_ground_ext to _ H1. search.

% Closed terms do not contain nominal constants.
Theorem term_ground : forall M, nabla x,
  {term (M x)} -> exists R, M = (x\ R).

STOP.

% Closing a closed term has no effect
Theorem term_close : forall L M N,
  {term M} -> close L M N -> M = N.
induction on 2. intros. case H2.
  search.

..

Theorem close_var : forall L M N A,
  ofctx L -> member (of M A) L -> close L M N -> reduce N A.
induction on 2. intros. case H1.
  case H2.
  case H2. case H3.

..

Theorem gen_app : forall L M N R,
  ctx L -> gen L (app M N) R ->
    exists MR NR, R = app MR NR /\ gen L M MR /\ gen L N NR.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H6. case H7. case H8. case H9. case H11.
  search.

Theorem gen_abs : forall L M R T,
  ctx L -> gen L (abs T M) R -> {type T} ->
    exists MR, R = abs T MR /\
      forall V, {term V} -> reduce T V ->
                  nabla x, gen (of x T :: L) (M x) (MR V).
induction on 1. intros. case H1.
  case H2. exists M. split.
    search.
    intros. search.
  case H2. apply type_ground to H3. case H8. case H9.
    apply IH to H4 H7 H3. case H10. case H11. case H12.
      exists MR. split.
        search.
        intros. apply term_ground to H15. case H17. case H18.
          apply H13 to H15 H16. case H19. case H20. clear H16. search.

Theorem generalized : forall L T S A,
  ctx L -> {L |- of T A} -> gen L T S -> reduce A S.
induction on 2. intros. case H2.
  apply lemma1 to H1 H4 H3. search.
  apply gen_app to H1 H3. case H6. case H7. case H8. case H10.
    apply IH to H1 H4 H11.
    apply IH to H1 H5 H9.
    case H12.
    apply H16 to H13.
    search.
  skip.

