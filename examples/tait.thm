%% Tait's logical relations argument for proving normalization for the
%% simply typed lambda calculus. This is based on the presentation in
%% Types and Programming Languages by Pierce.
%% [Work in progress]

%% Conventions:
%% Types: A, B, C
%% Terms: M, N, P, R
%% Values (Terms): V
%% Contexts: L, K

Def halts M :- exists V, {nstep M V} /\ {value V}.

%% Reduce is the logical relation used to prove normalization.
%% We write the term before the type to match the signature of "of".
%% This definition is not strictly admitted in the logic G due to the use
%% of reduce in a negative context. However, a more fine grained
%% notion of stratification (based on examining the arguments to predicates)
%% will allow this definition since the second argument is always smaller
%% in negative occurences.
Def reduce M top :- {of M top}, halts M.
Def reduce M (arrow A B) :-
  {of M (arrow A B)},
  halts M,
  (forall N, reduce N A -> reduce (app M N) B).

Theorem reduce_halts : forall A M, reduce M A -> halts M.
intros. case H1.
  search.
  search.

Theorem reduce_of : forall A M, reduce M A -> {of M A}.
intros. case H1.
  search.
  search.


%% Properties of evaluation

Theorem absurd_step_value : forall V M,
  {step V M} -> {value V} -> false.
intros. case H1.
  case H2.
  case H2.
  case H2.

Theorem step_det : forall M N P,
  {step M N} -> {step M P} -> N = P.
induction on 1. intros. case H1.
  case H2.
    apply IH to H3 H4. case H5. search.
    apply absurd_step_value to H3 H4. case H6.
    case H3.
  case H2.
    apply absurd_step_value to H5 H3. case H6.
    apply IH to H4 H6. case H7. search.
    apply absurd_step_value to H4 H5. case H6.
  case H2.
    case H4.
    apply absurd_step_value to H5 H3. case H6.
    search.

Theorem nstep_step_backward : forall M N V,
  {step M N} -> {nstep M V} -> {value V} -> {nstep N V}.
intros. case H2.
  apply absurd_step_value to H1 H3. case H4.
  apply step_det to H1 H4. case H6. search.

Theorem nstep_right : forall M N R,
  {nstep M N} -> {step N R} -> {nstep M R}.
induction on 1. intros. case H1.
  search.
  apply IH to H4 H2. search.

Theorem nstep_app_value : forall M N R,
  {value M} -> {nstep N R} -> {nstep (app M N) (app M R)}.
induction on 2. intros. case H2.
  search.
  apply IH to H1 H4.
    assert {step (app M N) (app M P)}. search.
      search.

Theorem halt_step_forward : forall M N,
  halts M -> {step M N} -> halts N.
intros. case H1. case H3. case H4.
  apply nstep_step_backward to H2 H5 H6. search.

Theorem halt_step_backward : forall M N,
  halts N -> {step M N} -> halts M.
intros. case H1. case H3. case H4.
  assert {nstep M V1}. search.
    search.

Theorem of_step_forward : forall M N A,
  {of M A} -> {step M N} -> {of N A}.
induction on 2. intros. case H2.
  case H1. apply IH to H4 H3. search.
  case H1. apply IH to H6 H4. search.
  case H1. case H4.
    inst H7 with n1 = M1.
      cut H8 with H5. search.

Theorem reduce_step_forward : forall M N A,
  reduce M A -> {step M N} -> reduce N A.
induction on 1. intros. case H1.
  apply of_step_forward to H3 H2.
    apply halt_step_forward to H4 H2.
      search.
  unfold.
    apply of_step_forward to H3 H2. search.
    apply halt_step_forward to H4 H2. search.
    intros. apply H5 to H6.
      apply IH to H7 _. search.

Theorem reduce_nstep_forward : forall M N A,
  reduce M A -> {nstep M N} -> reduce N A.
induction on 2. intros. case H2.
  search.
  apply reduce_step_forward to H1 H3. apply IH to H5 H4. search.

Theorem reduce_step_backward : forall M N A,
  reduce N A -> {step M N} -> {of M A} -> reduce M A.
induction on 1. intros. case H1.
  apply halt_step_backward to H5 H2. search.
  unfold.
    search.
    apply halt_step_backward to H5 H2. search.
    intros. apply H6 to H7.
      apply reduce_of to H7.
        apply IH to H8 _ _. search.

Theorem reduce_nstep_backward : forall M N A,
  reduce N A -> {nstep M N} -> {of M A} -> reduce M A.
induction on 2. intros. case H2.
  search.
  apply of_step_forward to H3 H4. apply IH to H1 H5 H6.
    apply reduce_step_backward to H7 H4 H3. search.


%% Properties about fresh, closed, and ground

% of_ctx defines the context of "of M A" judgments
Def of_ctx nil.
Def nabla x, of_ctx (of x A :: L) :- of_ctx L.

% term_ctx defines the context of "term M" judgments
Def term_ctx nil.
Def nabla x, term_ctx (term x :: L) :- term_ctx L.

% A term is closed if it is a valid term in an empty context
Def closed M :- {term M}.

Def nabla x, fresh x M.

Theorem member_fresh : forall X L E,
  member E L -> fresh X L -> fresh X E.
induction on 1. intros. case H1.
  case H2. search.
  assert fresh X L1.
    case H2. search.
    apply IH to H3 H4. search.

Theorem type_ground : forall A, nabla x,
  {type (A x)} -> exists B, A = (x\ B).
induction on 1. intros. case H1.
  search.
  apply IH to H2. case H4. case H5.
    apply IH to H3. case H6. case H7.
      search.

Theorem absurd_member_type_term_ctx : forall L A,
  member (type A) L -> term_ctx L -> false.
induction on 2. intros. case H2.
  case H1.
  case H1. apply IH to H4 H3. case H5.

Theorem type_ignores_term_ctx : forall L A,
  term_ctx L -> {L |- type A} -> {type A}.
induction on 2. intros. case H2.
  apply absurd_member_type_term_ctx to H3 H1. case H4.
  search.
  apply IH to H1 H3. apply IH to H1 H4. search.

Theorem type_ground_ext : forall L A, nabla x,
  term_ctx L -> {L |- type (A x)} -> exists B, A = (x\ B).
intros. apply type_ignores_term_ctx to H1 H2.
  apply type_ground to H3. search.

Theorem absurd_member_type_of_ctx : forall L A,
  member (type A) L -> of_ctx L -> false.
induction on 2. intros. case H2.
  case H1.
  case H1. apply IH to H4 H3. case H5.

Theorem type_ignores_of_ctx : forall L A,
  of_ctx L -> {L |- type A} -> {type A}.
induction on 2. intros. case H2.
  apply absurd_member_type_of_ctx to H3 H1. case H4.
  search.
  apply IH to H1 H3. apply IH to H1 H4. search.

Theorem term_ground_ext : forall L R, nabla x,
  term_ctx L -> {L |- term (R x)} -> exists M, R = (x\ M).
induction on 2. intros. case H2.
  apply member_fresh to H3 _. case H4. search.
  apply IH to H1 H3. case H5. case H6.
    apply IH to H1 H4. case H7. case H8.
      search.
  apply IH to _ H4. case H5. case H6.
    apply type_ground_ext to H1 H3. case H7. case H8.
      search.
  
Theorem term_ground : forall R, nabla x,
  {term (R x)} -> exists M, R = (x\ M).
intros. apply term_ground_ext to _ H1. search.

Theorem closed_ground : forall R, nabla x,
  closed (R x) -> exists M, R = (x\ M).
intros. case H1. apply term_ground to H2. search.

% This judgment aligns of_ctx with term_ctx
Def of_term_ctx nil nil.
Def nabla x, of_term_ctx (of x A :: L) (term x :: K) :-
               {type A}, of_term_ctx L K.

Theorem member_of_term_ctx : forall L K M A,
  of_term_ctx L K -> member (of M A) L -> member (term M) K.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H4 H5. search.
                     
Theorem of_closed_ext : forall L K M A,
  of_ctx L -> {L |- of M A} -> of_term_ctx L K -> {K |- term M}.
induction on 2. intros. case H2.
  apply member_of_term_ctx to H3 H4. search.
  apply IH to H1 H4 H3. apply IH to H1 H5 H3. search.
  apply type_ignores_of_ctx to H1 H4. case H6.
    apply IH to _ H5 _. search.

Theorem of_closed : forall M A, {of M A} -> closed M.
intros. apply of_closed_ext to _ H1 _. search.


%% Now we need to state the generalize theorem. This will require reasoning
%% about all possible closed instantiations of an open term.

% Suppose that {L |- of M A} is true. Then M is an open term with nominal
% constants that are listed in L. The judgment "close L M N" holds for all
% closed instantiations N of the nominal constants in M. The key to defining
% this judgment is the use of nabla in the head of a definition which
% extracts a nominal constant from L and M. The definition of "close" then
% substitutes for this nominal constant and continues processing the list L.
% Note: In the second clause, V is not mentioned in the head, thus it is
%       treated as existentially bound in the body.
Def close nil M M.
Def nabla x, close (of x A :: L) (R x) M :-
  reduce V A, closed V, {value V}, close L (R V) M.

% Closing a closed term has no effect
Theorem closed_close : forall L M N,
  closed M -> close L M N -> M = N.
induction on 2. intros. case H2.
  search.
  apply closed_ground to H1. case H7. case H8.
    apply IH to H1 H6. search.

Theorem close_var : forall L M N A,
  of_ctx L -> member (of M A) L -> close L M N -> reduce N A.
induction on 1. intros. case H1.
  case H2.
  case H2.
    case H3. apply closed_close to H6 H8. case H9. search.
    case H3. apply member_fresh to H5 _. case H10.
      apply IH to H4 H5 H9. search.

Theorem close_app : forall L M N R,
  of_ctx L -> close L (app M N) R ->
    exists MR NR, R = app MR NR /\ close L M MR /\ close L N NR.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H7. case H8. case H9. case H10. case H12.
    search.

Theorem close_abs : forall L M R A B,
  of_ctx L -> close L (abs A M) R ->
    {L |- of (abs A M) (arrow A B)} -> {type (arrow A B)} ->
      exists MR, R = abs A MR /\
        {of (abs A MR) (arrow A B)} /\
        (forall V, closed V -> {value V} -> reduce V A ->
                     nabla x, close (of x A :: L) (M x) (MR V)).
induction on 1. intros. case H1.
  case H2. exists M. split.
    search.
    intros. search.
  case H2. apply type_ground to H4. case H10. case H11.
    apply reduce_of to H6. inst H3 with n1 = V. cut H13 with H12.
      apply IH to H5 H9 H14 H4. case H15. case H16. case H17. case H19.
        exists MR. split. split.
          search.
          search.
          intros. apply closed_ground to H22. case H25. case H26.
            apply H18 to H22 H23 H24. case H27. case H28.
              clear H24. search.

Theorem tait_ext : forall L M R A,
  of_ctx L -> {L |- of M A} -> close L M R -> reduce R A.
induction on 2. intros. case H2.
  apply close_var to H1 H4 H3. search.
  apply close_app to H1 H3. case H6. case H7. case H8. case H10.
    apply IH to H1 H4 H11.
    apply IH to H1 H5 H9.
      case H12. apply H16 to H13. search.
  apply type_ignores_of_ctx to H1 H4.
    apply close_abs to H1 H3 _ H6. case H7. case H8. case H9. case H11. unfold.
      search.
      search.
      intros. % The rest is one single case
        apply reduce_halts to H13. case H14. case H15. case H16.
        apply reduce_nstep_forward to H13 H17.
        apply reduce_of to H19. apply of_closed to H20.
        apply H10 to H21 H18 H19. case H22.
        apply IH to _ H5 H23.
        apply reduce_of to H13.
        assert {value (abs A1 MR)}. search.
        apply nstep_app_value to H26 H17.
        assert {step (app (abs A1 MR) V1) (MR V1)}. search.
        apply nstep_right to H27 H28.
        apply reduce_nstep_backward to H24 H29 _. search.


Theorem tait : forall M A, {of M A} -> halts M.
intros. apply tait_ext to _ H1 _.
  apply reduce_halts to H2. search.
