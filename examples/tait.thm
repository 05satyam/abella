%% Tait's logical relations argument for proving normalization for the
%% simply typed lambda calculus. This is based on the presentation in
%% Types and Programming Languages by Pierce.

%% Conventions:
%% Types: A, B, C
%% Terms: M, N, P, R
%% Values (Terms): V
%% Contexts: L, K

Def halts M :- exists V, {nstep M V} /\ {value V}.

%% Reduce is the logical relation used to prove normalization. We
%% write the term before the type to match the signature of "of". This
%% definition is not admitted in the logic G due to the recursive use
%% of reduce in a negative context. However, we can augment G with a
%% more fine grained notion of stratification (based on examining the
%% arguments to predicates) and thereby allow this definition since
%% the second argument is always smaller in negative occurences.

Def reduce M top :- {of M top}, halts M.
Def reduce M (arrow A B) :-
  {of M (arrow A B)},
  halts M,
  (forall N, reduce N A -> reduce (app M N) B).

Theorem reduce_halts : forall A M, reduce M A -> halts M.
intros. case H1.
  search.
  search.

Theorem reduce_of : forall A M, reduce M A -> {of M A}.
intros. case H1.
  search.
  search.


%% Properties of evaluation

Theorem absurd_step_value : forall V M,
  {step V M} -> {value V} -> false.
intros. case H2. case H1.

Theorem step_det : forall M N P,
  {step M N} -> {step M P} -> N = P.
induction on 1. intros. case H1.
  case H2.
    apply IH to H3 H4. case H5. search.
    apply absurd_step_value to H3 H4. case H6.
    case H3.
  case H2.
    apply absurd_step_value to H5 H3. case H6.
    apply IH to H4 H6. case H7. search.
    apply absurd_step_value to H4 H5. case H6.
  case H2.
    case H4.
    apply absurd_step_value to H5 H3. case H6.
    search.

Theorem step_follows_nstep : forall M N V,
  {step M N} -> {nstep M V} -> {value V} -> {nstep N V}.
intros. case H2.
  apply absurd_step_value to H1 H3. case H4.
  apply step_det to H1 H4. case H6. search.

% nstep is defined by left recursion on step, so this lemma tells us
% that it acts right recursively as well
Theorem nstep_right : forall M N R,
  {nstep M N} -> {step N R} -> {nstep M R}.
induction on 1. intros. case H1.
  search.
  apply IH to H4 H2. search.

Theorem nstep_app_value : forall M N R,
  {value M} -> {nstep N R} -> {nstep (app M N) (app M R)}.
induction on 2. intros. case H2.
  search.
  apply IH to H1 H4.
    assert {step (app M N) (app M P)}. search.
      search.

Theorem halt_step_forward : forall M N,
  halts M -> {step M N} -> halts N.
intros. case H1. case H3.
  apply step_follows_nstep to H2 H4 H5. search.

Theorem halt_step_backward : forall M N,
  halts N -> {step M N} -> halts M.
intros. case H1. case H3.
  assert {nstep M V1}. search.
    search.

Theorem of_step_forward : forall M N A,
  {of M A} -> {step M N} -> {of N A}.
induction on 2. intros. case H2.
  case H1. apply IH to H4 H3. search.
  case H1. apply IH to H6 H4. search.
  case H1. case H4.
    inst H7 with n1 = M1.
      cut H8 with H5. search.

Theorem reduce_step_forward : forall M N A,
  reduce M A -> {step M N} -> reduce N A.
induction on 1. intros. case H1.
  apply of_step_forward to H3 H2.
    apply halt_step_forward to H4 H2.
      search.
  unfold.
    apply of_step_forward to H3 H2. search.
    apply halt_step_forward to H4 H2. search.
    intros. apply H5 to H6.
      apply IH to H7 _. search.

Theorem reduce_nstep_forward : forall M N A,
  reduce M A -> {nstep M N} -> reduce N A.
induction on 2. intros. case H2.
  search.
  apply reduce_step_forward to H1 H3. apply IH to H5 H4. search.

Theorem reduce_step_backward : forall M N A,
  reduce N A -> {step M N} -> {of M A} -> reduce M A.
induction on 1. intros. case H1.
  apply halt_step_backward to H5 H2. search.
  unfold.
    search.
    apply halt_step_backward to H5 H2. search.
    intros. apply H6 to H7.
      apply reduce_of to H7.
        apply IH to H8 _ _. search.

Theorem reduce_nstep_backward : forall M N A,
  reduce N A -> {nstep M N} -> {of M A} -> reduce M A.
induction on 2. intros. case H2.
  search.
  apply of_step_forward to H3 H4. apply IH to H1 H5 H6.
    apply reduce_step_backward to H7 H4 H3. search.


%% Properties about nominal constants, e.g. where they can and cannot occur.
%% Also properties about the contexts of judgments.

% of_ctx defines the context of "of M A" judgments. The judgment {type A}
% ensures that all types in the context are well-formed, e.g. they do
% not contain nominal constants.
Def of_ctx nil.
Def nabla x, of_ctx (of x A :: L) :- {type A}, of_ctx L.

% term_ctx defines the context of "term M" judgments
Def term_ctx nil.
Def nabla x, term_ctx (term x :: L) :- term_ctx L.

% A term is closed if it is a valid term in an empty context
Def closed M :- {term M}.

Def nabla x, fresh x M.

Theorem member_fresh : forall X L E,
  member E L -> fresh X L -> fresh X E.
induction on 1. intros. case H1.
  case H2. search.
  assert fresh X L1.
    case H2. search.
    apply IH to H3 H4. search.

% Types do not contain nominal constants, thus any dependencies on
% nominal constants can be pruned
Theorem prune_type : forall A, nabla x,
  {type (A x)} -> exists B, A = (x\ B).
induction on 1. intros. case H1.
  search.
  apply IH to H2. case H4.
    apply IH to H3. case H5.
      search.

Theorem absurd_member_type_term_ctx : forall L A,
  member (type A) L -> term_ctx L -> false.
induction on 2. intros. case H2.
  case H1.
  case H1. apply IH to H4 H3. search.

Theorem type_ignores_term_ctx : forall L A,
  term_ctx L -> {L |- type A} -> {type A}.
induction on 2. intros. case H2.
  apply absurd_member_type_term_ctx to H3 H1. case H4.
  search.
  apply IH to H1 H3. apply IH to H1 H4. search.

Theorem absurd_member_type_of_ctx : forall L A,
  member (type A) L -> of_ctx L -> false.
induction on 2. intros. case H2.
  case H1.
  case H1. apply IH to H5 H4. search.

Theorem type_ignores_of_ctx : forall L A,
  of_ctx L -> {L |- type A} -> {type A}.
induction on 2. intros. case H2.
  apply absurd_member_type_of_ctx to H3 H1. case H4.
  search.
  apply IH to H1 H3. apply IH to H1 H4. search.

% A term cannot contain a nominal variable which does not appear in L
Theorem prune_term : forall L R, nabla x,
  term_ctx L -> {L |- term (R x)} -> exists M, R = (x\ M).
induction on 2. intros. case H2.
  apply member_fresh to H3 _. case H4. search.
  apply IH to H1 H3. case H5.
    apply IH to H1 H4. case H6.
      search.
  apply IH to _ H4. case H5.
    apply type_ignores_term_ctx to H1 H3. apply prune_type to H6. case H7.
      search.

% Closed terms cannot contain any nominal constants
Theorem prune_closed : forall R, nabla x,
  closed (R x) -> exists M, R = (x\ M).
intros. case H1. apply prune_term to _ H2. search.

% This judgment aligns of_ctx with term_ctx
Def dual_ctxs nil nil.
Def nabla x, dual_ctxs (of x A :: L) (term x :: K) :- dual_ctxs L K.

Theorem member_dual_ctxs : forall L K M A,
  dual_ctxs L K -> member (of M A) L -> member (term M) K.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem of_term_ext : forall L K M A,
  of_ctx L -> {L |- of M A} -> dual_ctxs L K -> {K |- term M}.
induction on 2. intros. case H2.
  apply member_dual_ctxs to H3 H4. search.
  apply IH to H1 H4 H3. apply IH to H1 H5 H3. search.
  apply type_ignores_of_ctx to H1 H4.
    apply IH to _ H5 _. search.

Theorem reduce_closed : forall M A, reduce M A -> closed M.
intros. apply reduce_of to H1. apply of_term_ext to _ H2 _. search.

Theorem prune_reduce : forall R A, nabla x,
  reduce (R x) A -> exists M, R = (x\ M).
intros. apply reduce_closed to H1. apply prune_closed to H2.
  case H3. search.

Theorem of_ctx_type : forall L M A,
  of_ctx L -> member (of M A) L -> {type A}.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H4 H5. search.
  
Theorem of_type : forall L K M A,
  of_ctx L -> {L |- of M A} -> {type A}.
induction on 2. intros. case H2.
  apply of_ctx_type to H1 H3. search.
  apply IH to H1 H3. case H5. search.
  apply type_ignores_of_ctx to H1 H3.
    apply IH to _ H4. search.


%% Now we need to state the generalize theorem. This will require reasoning
%% about all possible closed instantiations of an open term.

% Suppose that {L |- of M A} is true. Then M is an open term with nominal
% constants that are listed in L. The judgment "subst L M N" holds for all
% instantiations N of the nominal constants in M with values that satisfy
% the reduce relation for their respective types. The key to defining this
% judgment is the use of nabla in the head of a definition which extracts
% a nominal constant from L and M. The definition of subst then substitutes
% for this nominal constant and continues processing the list L.
Def subst nil M M.
Def nabla x, subst (of x A :: L) (R x) M :-
  exists V, reduce V A /\ {value V} /\ subst L (R V) M.

% Subst on a closed term has no effect
Theorem closed_subst : forall L M N,
  closed M -> subst L M N -> M = N.
induction on 2. intros. case H2.
  search.
  case H3. apply prune_closed to H1. case H7.
    apply IH to H1 H6. search.

Theorem subst_var : forall L M N A,
  of_ctx L -> member (of M A) L -> subst L M N -> reduce N A.
induction on 1. intros. case H1.
  case H2.
  case H2.
    case H3. case H6. apply reduce_closed to H7.
      apply closed_subst to H10 H9. case H11. search.
    case H3. case H7. apply member_fresh to H6 _. case H11.
      apply IH to H5 H6 H10. search.

Theorem subst_app : forall L M N R,
  of_ctx L -> subst L (app M N) R ->
    exists MR NR, R = app MR NR /\ subst L M MR /\ subst L N NR.
induction on 1. intros. case H1.
  case H2. search.
  case H2. case H5. apply IH to H4 H8. case H9.
    search.

% This theorem has a {type A} hypothesis to ensure that no nominal variables
% can appear in A and thus substitutions do not affect A
Theorem subst_abs : forall L M R A,
  of_ctx L -> subst L (abs A M) R -> {type A} ->
      exists MR, R = abs A MR /\
        (forall V, reduce V A -> {value V} ->
                     nabla x, subst (of x A :: L) (M x) (MR V)).
induction on 1. intros. case H1.
  case H2. exists M. split.
    search.
    intros. search.
  case H2. case H6. apply prune_type to H3. case H10.
    apply IH to H5 H9 H3. case H11.
      exists MR. split.
        search.
        intros. apply prune_reduce to H13. case H15.
          apply H12 to H13 H14. case H16. case H17.
            clear H13. search.

Theorem subst_preserves_type : forall L M N A,
  of_ctx L -> subst L M N -> {L |- of M A} -> {of N A}.
induction on 1. intros. case H1.
  case H2. search.
  case H2. case H6.
    apply reduce_of to H7. inst H3 with n1 = V1. cut H11 with H10.
      apply of_type to _ H3. apply prune_type to H13. case H14.
        apply IH to H5 H9 H12. search.

Theorem tait_ext : forall L M R A,
  of_ctx L -> {L |- of M A} -> subst L M R -> reduce R A.
induction on 2. intros. case H2 (keep).
  apply subst_var to H1 H4 H3. search.
  apply subst_app to H1 H3. case H6.
    apply IH to H1 H4 H7.
      apply IH to H1 H5 H8.
        case H9. apply H13 to H10. search.
  apply type_ignores_of_ctx to H1 H4.
    apply subst_abs to H1 H3 H6. case H7.
      apply subst_preserves_type to H1 H3 H2. unfold.
        search.
        search.
        intros. % The rest is one single case
          apply reduce_halts to H10. case H11. case H12.
          apply reduce_nstep_forward to H10 H13.
          apply H8 to H15 H14.
          apply IH to _ H5 H16.
          assert {value (abs A1 MR)}. search.
          apply nstep_app_value to H18 H13.
          assert {step (app (abs A1 MR) V1) (MR V1)}. search.
          apply nstep_right to H19 H20.
          apply reduce_nstep_backward to H17 H21 _.
            apply reduce_of to H10. search.
            search.


Theorem tait : forall M A, {of M A} -> halts M.
intros. apply tait_ext to _ H1 _.
  apply reduce_halts to H2. search.
