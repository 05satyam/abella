%% Paths through lambda terms
%%
%% Here we prove: if all the paths in the lambda term X also exist in
%% the lambda term Y then X = Y.
%%
%% This example would really benefit from some polymorphism

Specification "path".

Define tm_var : tm -> prop by
  nabla x, tm_var x.

Define path_var : path -> prop by
  nabla x, path_var x.

Theorem member_prune_path : forall E L, nabla (x:path),
  member (E x) L -> exists F, E = y\F.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Define ctxs : olist -> olist -> prop by
  ctxs nil nil ;
  nabla x p, ctxs (tm x :: L) (path x p :: K) := ctxs L K.

Theorem ctxs_inv1 : forall D L K,
  ctxs L K -> member D L ->
    exists X, D = tm X /\ tm_var X /\
      exists P, member (path X P) K /\ path_var P.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem ctxs_inv2 : forall D L K,
  ctxs L K -> member D K ->
    exists X P, D = path X P /\ tm_var X /\ path_var P.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem member_path_unique : forall L K X Y F,
  ctxs L K -> member (path X F) K -> member (path Y F) K -> X = Y.
induction on 2. intros. case H2.
  case H3.
    search.
    case H1. apply member_prune_path to H4.
  case H3.
    case H1. apply member_prune_path to H4.
    case H1. apply IH to H6 H4 H5. search.

Theorem path_prune : forall L K M N, nabla x y,
  ctxs L K -> {K, path x y |- path (M x) (N x y)} -> exists P, N = x\P.
induction on 2. intros. case H2.
  apply ctxs_inv2 to _ H3. case H4. case H6.
    search.
    search.
  apply IH to H1 H3. search.
  apply IH to H1 H3. search.
  apply IH to _ H3. search.
  search.

Theorem path_app : forall L K M N Y,
  ctxs L K -> (forall P, {K |- path (app M N) P} -> {K |- path Y P}) ->
    exists YM YN, Y = app YM YN.
intros.
assert {K |- path (app M N) (left done)}.
apply H2 to H3.
case H4.
  apply ctxs_inv2 to H1 H5. case H6. case H8.
  search.

Theorem path_abs : forall L K R Y,
  ctxs L K -> (forall P, {K |- path (abs R) P} -> {K |- path Y P}) ->
    exists YR, Y = abs YR.
intros.
assert {K |- path (abs R) (bnd x\ done)}.
apply H2 to H3.
case H4.
  apply ctxs_inv2 to H1 H5. case H6. case H8.
  search.

Theorem path_equal : forall L K X Y,
  ctxs L K -> {L |- tm X} ->
    (forall P, {K |- path X P} -> {K |- path Y P}) -> X = Y.
induction on 2. intros. case H2.

  % X is a variable
  apply ctxs_inv1 to H1 H4. case H5.
  assert {K |- path X P}.
  apply H3 to H9.
  case H8. case H10.
  apply ctxs_inv2 to H1 H11. case H12.
  apply member_path_unique to H1 H7 H11. search.

  % X = app M N
  apply path_app to H1 H3.

    % Apply the IH to M
    assert forall P, {K |- path M P} -> {K |- path YM P}.
      intros.
      assert {K |- path (app M N) (left P)}.
      apply H3 to H7. case H8.
        apply ctxs_inv2 to H1 H9. case H10. case H11.
        search.
    apply IH to H1 H4 H6.

    % Apply the IH to M
    assert forall P, {K |- path N P} -> {K |- path YN P}.
      intros.
      assert {K |- path (app M N) (right P)}.
      apply H3 to H8. case H9.
        apply ctxs_inv2 to H1 H10. case H11. case H12.
        search.
    apply IH to H1 H5 H7.

    % Finish this case
    search.

  % X = abs R
  apply path_abs to H1 H3.

    % Apply the IH to (R n1)
    assert forall P, {K, path n1 n2 |- path (R n1) P} ->
                     {K, path n1 n2 |- path (YR n1) P}.
      intros.
      apply path_prune to H1 H5.
      assert {K |- path (abs R) (bnd P2)}.
      apply H3 to H6. case H7.
        apply ctxs_inv2 to H1 H8. case H9. case H10.
        search.
    assert ctxs (tm n1 :: L) (path n1 n2 :: K).
    apply IH to H6 H4 H5.

    % Finish this case
    search.

