%% Comparison between internal and external definition of seq

% Assume that prog has no defining clauses for now
Define prog A B := false.

Define seq L t.
Define seq L (atom A) := member A L.
Define seq L (and A B) := seq L A /\ seq L B.
Define seq L (A => B) := seq (A :: L) B.
Define seq L (pi G) := nabla x, seq L (G x).
Define seq L (sigma G) := exists X, seq L (G X).
Define seq L (atom A) := exists B, prog A B /\ seq L B.

Theorem external : forall S T,
  seq nil (pi x\ p x S => pi y\ p y T => atom (p x T)) -> S = T.
intros.
case H1.
case H2.
case H3.
case H4.
case H5.
case H6.
  case H7.
    search.
    case H8.
  case H6.

Theorem internal : forall S T,
  {pi x\ p x S => pi y\ p y T => p x T} -> S = T.
intros.
case H1.
case H2.
case H3.
  search.
  case H4.

%% An external version of add.mod/thm
%%
%% The primary difference (besides the extra syntax of "atom") is that
%% for (seq nil P) we have to consider both (member P nil) and
%% (prog P B, seq nil B). Then we have to do case analysis on (prog P B)
%% to unfold the body of P. In the internal version, all of this is
%% contained in one case analysis.

Define prog (nat z) t.
Define prog (nat (s N)) (atom (nat N)).

Define prog (add z N N) t.
Define prog (add (s A) B (s C)) (atom (add A B C)).

Theorem add_base : forall N,
  seq nil (atom (nat N)) -> seq nil (atom (add N z N)).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3. search.

Theorem add_step : forall A B C,
  seq nil (atom (add A B C)) -> seq nil (atom (add A (s B) (s C))).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3. search.

Theorem add_comm : forall A B C, seq nil (atom (nat B)) ->
  seq nil (atom (add A B C)) -> seq nil (atom (add B A C)).
induction on 2. intros. case H2.
  case H3.
  case H3.
    apply add_base to H1. search.
    apply IH to H1 H4. apply add_step to H5. search.


%% A benefit of the external definition of seq is that it allows us to prove
%% meta-theoremas about lambda prolog.

Define list nil.
Define list (X :: A) := list A.

Theorem seq_subset : forall L1 L2 G,
  seq L1 G -> (forall X, member X L1 -> member X L2) -> seq L2 G.
induction on 1. intros. case H1.
  search.
  apply H2 to H3. search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  assert forall X, member X (A :: L1) -> member X (A :: L2).
    intros. case H4.
      search.
      apply H2 to H5. search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.
  apply IH to H3 H2. search.
  apply IH to H4 H2. search.

Theorem seq_cut : forall K L G,
  list L -> seq (K :: L) G -> seq L (atom K) -> seq L G.
induction on 2. intros. case H2.
  search.
  case H4.
    search.  % Key case: G=K
    search.
  apply IH to H1 H4 H3. apply IH to H1 H5 H3. search.
  assert forall X, member X (A :: K :: L) -> member X (K :: A :: L).
    intros. case H5.
      search.
      case H6.
        search.
        search.
    apply seq_subset to H4 H5.
    % We want to apply IH but we can't because we got
    %   seq (A :: K :: L) B *  and
    %   seq (K :: A :: L) B    so we were not able to keep the star
    %                          with that lemma...
    skip.
  apply IH to H1 H4 H3. search.
  apply IH to H1 H4 H3. search.
  apply IH to H1 H5 H3. search.
