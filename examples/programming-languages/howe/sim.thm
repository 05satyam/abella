Specification "pclf".
Close ty, tm.

Import "subst".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem subjred : forall M T V,
  {of M T} -> {eval M V} -> {of V T}.
induction on 2. intros. case H2.
  search.
  case H1. apply IH to *H5 *H3. case H7. inst *H8 with n1 = N. cut *H9 with *H6.
    apply IH to *H10 *H4. search.
  case H1. apply IH to *H6 *H4. search.
  case H1. apply IH to *H5 *H3. case H8. inst *H7 with n1 = H, n2 = K.
    cut *H11 with *H9. cut *H12 with *H10. apply IH to *H13 *H4. search.
  case H1. apply IH to *H6 *H4. search.
  case H1. apply IH to *H5 *H3. case H8. inst *H7 with n1 = K. cut *H10 with *H9.
    apply IH to *H11 *H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

CoDefine sim : ty -> tm -> tm -> prop by
; sim nat M N :=
    ({eval M zero} -> {eval N zero}) /\
    (forall U, {eval M (succ U)} ->
     exists V, {eval N (succ V)} /\ sim nat U V)
; sim top M N :=
    {eval M unit} -> {eval N unit}
; sim (arr S T) M N :=
    forall MR, {eval M (lam MR)} ->
    exists NR, {eval N (lam NR)} /\
    forall x, {of x S} -> sim T (MR x) (NR x)
; sim (list T) M N :=
    ({eval M nill} -> {eval N nill}) /\
    (forall MH MK, {eval M (cons MH MK)} ->
     exists NH NK, {eval N (cons NH NK)} /\
       sim T MH NH /\
       sim (list T) MK NK)
.

Theorem sim_refl : forall T M, {ty T} -> {of M T} -> sim T M M.
coinduction. intros. case H1.
  unfold. search.
  unfold.
    search.
    intros. apply subjred to H2 H3. case H4. apply CH to _ H5. search.
  unfold.
    search.
    intros. apply subjred to H2 H4. case H5.
      apply CH to _ *H6. apply CH to _ *H7. search.
  unfold. intros.
    apply subjred to H2 H5. case H6. witness MR. split. search.
    intros. inst *H7 with n1 = x. cut *H9 with *H8. backchain CH.

Theorem sim_trans : forall T M N K, sim T M N -> sim T N K -> sim T M K.
coinduction. intros. case H1.
  case H2. unfold.
    intros. backchain H5. backchain H3.
    intros. apply *H4 to *H7. apply *H6 to *H8.
      apply CH to *H9 *H11. search.
  case H2. unfold. intros.
    backchain H4. backchain H3.
  case H2. unfold. intros.
    apply *H3 to *H5. apply *H4 to *H6. witness NR1. split. search.
    intros. apply *H7 to H10. apply *H9 to *H10. backchain CH.
  case H2. unfold.
    intros. backchain H5. backchain H3.
    intros. apply *H4 to *H7. apply *H6 to *H8.
      apply CH to *H9 *H12. apply CH to *H10 *H13. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define osim : olist -> ty -> tm -> tm -> prop by
osim G T M N :=
  forall SS SM SN,
    ofsub nil SS G ->
    {SS |- cp M SM} ->
    {SS |- cp N SN} ->
    sim T SM SN.

Theorem osim_refl : forall G T M, {ty T} -> {G |- of M T} -> osim G T M M.
intros. unfold. intros.
  apply subst to H3 H2. apply cp_det to H3 *H6 H4.
    apply cp_det to H3 *H5 H4. backchain sim_refl.

Theorem osim_trans : forall G T M N K,
  {G |- of M T} -> {G |- of N T} -> {G |- of K T} ->
  osim G T M N -> osim G T N K ->
  osim G T M K.
intros. unfold. intros. rename SN to SK.
  apply subst to H6 H1. apply cp_det to H6 *H9 H7.
  apply subst to H6 H2. rename SM2 to SN.
  apply subst to H6 H3. apply cp_det to H6 *H13 H8.
  Hs : case H4. apply *Hs to H6 *H7 H11.
  Hs : case H5. apply *Hs to H6 *H11 *H8.
  backchain sim_trans.

Theorem osim_cus : forall G SS D T M N SM SN,
  {D |- of M T} -> {D |- of N T} -> osim D T M N ->
  ofsub G SS D ->
  {SS |- cp M SM} -> {SS |- cp N SN} ->
  osim G T SM SN.
intros. unfold. intros.
  apply compose_exists to H7 H4.
  apply compose_map to H7 H4 H10 *H1 *H5 *H8.
  apply compose_map to H7 H4 H10 *H2 *H6 *H9.
  Hs : case H3. apply *Hs to *H11 *H12 *H13.
  search.