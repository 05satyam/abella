%% Paths through lambda terms using a single logic approach
%%
%% Here we prove: if all the paths in the lambda term X also exist in
%% the lambda term Y then X = Y.

Define nabla x, name x.

Define nabla x, tm (L x) x := nabla x, member x (L x).
Define tm L (app M N) := tm L M /\ tm L N.
Define tm L (abs R) := nabla x, tm (x :: L) (R x).

Define nabla x, path (K x) x x := nabla x, member x (K x).
Define path K (app M N) (left P) := path K M P.
Define path K (app M N) (right P) := path K N P.
Define path K (abs R) (bnd S) := nabla x, path (x :: K) (R x) (S x).
Define path K M done. % we allow partial paths

% NOTE: We use a single nabla variable in the abstraction case since
% otherwise we need to prove pruning lemmas (which are very painful
% without the two-level approach).


Define ctx nil.
Define nabla x, ctx (x :: L) := ctx L.

Theorem path_app : forall L M N Y,
  ctx L -> (forall P, path L (app M N) P -> path L Y P) ->
    exists YM YN, Y = app YM YN.
intros.
assert path L (app M N) (left done).
apply H2 to H3.
case H4. search.

Theorem path_abs : forall L R Y,
  ctx L -> (forall P, path L (abs R) P -> path L Y P) ->
    exists YR, Y = abs YR.
intros.
assert path L (abs R) (bnd x\ done).
apply H2 to H3.
case H4. search.

Theorem path_equal : forall L X Y,
  ctx L -> tm L X ->
    (forall P, path L X P -> path L Y P) -> X = Y.
induction on 2. intros. case H2.

  % X is a variable
  assert path (L n1) n1 n1.
  apply H3 to H5.
  case H6. search.

  % X = app M N
  apply path_app to H1 H3.

    % Apply the IH to M
    assert forall P, path L M P -> path L YM P.
      intros.
      assert path L (app M N) (left P).
      apply H3 to H7. case H8.
      search.
    apply IH to H1 H4 H6.

    % Apply the IH to M
    assert forall P, path L N P -> path L YN P.
      intros.
      assert path L (app M N) (right P).
      apply H3 to H8. case H9.
      search.
    apply IH to H1 H5 H7.

    % Finish this case
    search.

  % X = abs R
  apply path_abs to H1 H3.

    % Apply the IH to (R n1)
    assert forall P, path (n1 :: L) (R n1) P ->
                     path (n1 :: L) (YR n1) P.
      intros.
      assert path L (abs R) (bnd P).
      apply H3 to H6. case H7.
      search.
    assert ctx (n1 :: L).
    apply IH to H6 H4 H5.

    % Finish this case
    search.
