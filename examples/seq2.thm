%% A revised external definition of seq that allows for quantification
%% over lambda prolog programs.

%% We add the argument P representing the lambda prolog program so that
%% we can quantify over it.
Def seq P L t.
Def seq P L (atom A) :- member A L.
Def seq P L (and A B) :- seq P L A, seq P L B.
Def seq P L (A => B) :- seq P (A :: L) B.
Def seq P L (pi G) :- nabla x, seq P L (G x).
Def seq P L (sigma G) :- seq P L (G X).
Def seq P L (atom A) :- lookup A P B, seq P L B.

Def lookup A (atom A) t.
Def lookup A (imp B A) B.
Def lookup A (and P1 P2) B :- lookup A P1 B.
Def lookup A (and P1 P2) B :- lookup A P2 B.
Def lookup A (pi P) B :- lookup A (P X) B.

Theorem external : forall S T,
  seq nil nil (pi x\ p x S => pi y\ p y T => atom (p x T)) -> S = T.
intros.
case H1.
case H2.
case H3.
case H4.
case H5.
case H6.
case H7.
  case H8. case H9.
    search.
    case H10.
  case H8.

Theorem internal : forall S T,
  {pi x\ p x S => pi y\ p y T => p x T} -> S = T.
intros.
case H1.
case H2.
case H3.
  search.
  case H4.

%% An external version of add.mod/thm
%%
%% This is the primary downside of this encoding: the resulting
%% terms are quite large and hard to reason about.

Def prog (and (pi N\ (atom (add z N N)))
              (pi A\ pi B\ pi C\
                (imp (atom (add A B C)) (add (s A) B (s C))))).

Theorem add_test : forall P,
  prog P -> seq P nil (atom (add (s (s z)) (s z) (s (s (s z))))).
intros. case H1.
  search.

Theorem add_base : forall N P,
  prog P -> seq P nil (atom (nat N)) -> seq P nil (atom (add N z N)).
% induction on 2. intros. case H1. case H2.
skip.

%% A benefit of the external definition of seq is that it allows us to prove
%% meta-theoremas about lambda prolog. But first we need some properties
%% about lists.

Def list nil.
Def list (X :: A) :- list A.

Def select (X :: A) X A.
Def select (Y :: A) X (Y :: B) :- select A X B.

Def perm nil nil.
Def perm (X :: A') B :- select B X B', perm A' B'.

Theorem select_member_base : forall X L1 L2,
  select L1 X L2 -> member X L1.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem select_member_step : forall X Y L1 L2,
  select L1 X L2 -> member Y L2 -> member Y L1.
induction on 1. intros. case H1.
  search.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem perm_member : forall X L1 L2,
  member X L1 -> perm L1 L2 -> member X L2.
induction on 2. intros. case H2.
  search.
  case H1.
    apply select_member_base to H3. search.
    apply IH to H5 H4. apply select_member_step to H3 H6. search.

Theorem perm_refl : forall L,
  list L -> perm L L.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

% Theorem seq_subset : forall P L1 L2 G,
%  seq P L1 G -> (forall X, member X L1 -> member X L2) -> seq P L2 G.
%
% We would like to prove this theorem, but since it has a complicated term
% inside on the left of an arrow, we will need some sort of induction on
% meta-terms in order to complete the proof in the current system.
    
Theorem seq_perm : forall P L1 L2 G,
  seq P L1 G -> perm L1 L2 -> seq P L2 G.
induction on 1. intros. case H1.
  search.
  apply perm_member to H3 H2. search.
  apply IH to H3 H2. apply IH to H4 H2. search.
  apply IH to H3 _. search.
  case H3. apply IH to H4 H2. search.
  apply IH to H3 H2. search.
  apply IH to H4 H2. search.

Theorem seq_cut : forall P K L G,
  list L -> seq P (K :: L) G -> seq P L (atom K) -> seq P L G.
induction on 2. intros. case H2.
  search.
  case H4.
    search.  % Key case: G=K
    search.
  apply IH to H1 H4 H3. apply IH to H1 H5 H3. search.
  assert seq P (K :: A :: L) B.
    assert perm (A :: K :: L) (K :: A :: L).
      apply perm_refl to H1. search.
      apply seq_perm to H4 H5. search.
    % We want to apply IH but we can't because we got
    %   seq (A :: K :: L) B *  and
    %   seq (K :: A :: L) B    so we were not able to keep the star
    %                          with that lemma...
    skip.
  case H4. apply IH to H1 H5 H3. search.
  apply IH to H1 H4 H3. search.
  apply IH to H1 H5 H3. search.
