%% Normalization for the simply typed lambda calculus
%% [Work in progress]
%%
%% It is not yet clear how best to formalize that a term halts.

Def halts T :- exists V, {nstep T V} /\ {value V}.

Def reduce top T :- {typeof T top}, halts T.
Def reduce (arrow A B) T :-
  {typeof T (arrow A B)},
  halts T,
  (forall S, reduce A S -> reduce B (app T S)).

Theorem reduce_halts : forall A T, reduce A T -> halts T.
intros. case H1.
  search.
  search.

Theorem reduce_typeof : forall A T, reduce A T -> {typeof T A}.
intros. case H1.
  search.
  search.

Theorem halt_step_forward : forall S T,
  halts S -> {step S T} -> halts T.
skip.

Theorem halt_step_backward : forall S T,
  halts T -> {step S T} -> halts S.
skip.

Theorem typeof_step_forward : forall S T A,
  {typeof S A} -> {step S T} -> {typeof T A}.
induction on 2. intros. case H2.
  case H1. apply IH to H4 H3. search.
  case H1. apply IH to H6 H4. search.
  case H1. case H4.
    inst H6 with n1 = M.
      cut H7 with H5. search.

Theorem reduce_step_forward : forall S T C,
  {type C} -> {typeof S C} -> {step S T} -> reduce C S -> reduce C T.
induction on 1. intros. case H1.
  case H4.
    apply halt_step_forward to H6 H3.
      apply typeof_step_forward to H2 H3.
        search.
  case H4. unfold.
    apply typeof_step_forward to H2 H3. search.
    apply halt_step_forward to H8 H3. search.
    intros. apply H9 to H10.
      apply IH to H6 _ _ H11.
        case H11. search. search.
        search.

Theorem reduce_step_backward : forall R T C,
  {type C} -> {typeof R C} -> {step R T} -> reduce C T -> reduce C R.
induction on 1. intros. case H1.
  case H4.
    apply halt_step_backward to H6 H3.
      apply typeof_step_forward to H2 H3.
        search.
  case H4. unfold.
    search.
    apply halt_step_backward to H8 H3. search.
    intros. apply H9 to H10.
      apply IH to H6 _ _ H11.
        case H10. search. search.
        search.

%% Stating the generalized theorem will require some careful work
        
Def ctx nil.
Def nabla x, ctx (typeof x T :: L) :- ctx L.

% Gopalan also suggested splitting gen into two predicates, one which
% matches L with a list V of values and another which substitutes those
% values. Then the final theorem would quantify over V as well.

Def gen nil T T.
Def nabla x, gen (typeof x A :: L) (T x) S :-
  reduce A V, gen L (T V) S.

Theorem lemma1 : forall L T A S,
  ctx L -> member (typeof T A) L -> gen L T S -> reduce A S.
skip.

Theorem gen_app : forall L M N S,
  ctx L -> gen L (app M N) S ->
    exists MS NS, S = app MS NS /\ gen L M MS /\ gen L N NS.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H5. case H6. case H7. case H8. case H10.
  search.

Theorem type_ground : forall T, nabla n1,
  {type (T n1)} -> exists S, T = (x\ S).
induction on 1. intros. case H1.
  search.
  apply IH to H2. case H4. case H5.
    apply IH to H3. case H6. case H7.
      search.

Theorem gen_abs : forall L R S T,
  ctx L -> gen L (abs T R) S -> {type T} ->
    exists RS, S = abs T RS /\
      forall V, reduce T V -> nabla x, gen (typeof x T :: L) (R x) (RS V).
induction on 1. intros. case H1.
  case H2. exists R. split.
    search.
    intros. search.
  case H2. apply type_ground to H3. case H7. case H8.
    apply IH to H4 H6 H3. case H9. case H10. case H11.
      exists RS. split.
        search.
        intros. apply H12 to H14. skip.

Theorem generalized : forall L T S A,
  ctx L -> {L |- typeof T A} -> gen L T S -> reduce A S.
induction on 2. intros. case H2.
  apply lemma1 to H1 H4 H3. search.
  apply gen_app to H1 H3. case H6. case H7. case H8. case H10.
    apply IH to H1 H4 H11.
    apply IH to H1 H5 H9.
    case H12.
    apply H16 to H13.
    search.
  skip.

