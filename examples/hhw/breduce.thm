Specification "breduce".

Close tm, path.
 
Define ctx2 : olist -> olist -> prop by
  ctx2 nil nil
; nabla x p,
    ctx2 (breduce x x :: G) (path x p :: D) := ctx2 G D
; nabla x,
    ctx2 ((pi u\ breduce N u => breduce x u) :: G)
         ((pi q\ path N q => path x q) :: D) :=
      ctx2 G D.

Define name : tm -> prop by
  nabla n, name n.

Define fresh : tm -> tm -> prop by
  nabla n, fresh n X.

Define pname : path -> prop by
  nabla p, pname p.

Theorem ctx2_mem_G :
    forall G D F,
    ctx2 G D -> member F G ->
    (   (exists x, F = breduce x x /\ name x)
     \/ (exists x N, F = (pi u\ breduce N u => breduce x u) /\ fresh x N)).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4.
     case H5.
     search.
     search.
  case H2.
    search.
    apply IH to H3 H4. case H5.
     search.
     search.

Theorem ctx2_mem_D :
  forall G D F,
  ctx2 G D -> member F D ->
  (   (exists x p, F = path x p /\ name x /\ pname p)
   \/ (exists x N, F = (pi q\ path N q => path x q) /\ fresh x N) ).
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4.
     case H5.
       search.
       search.
  case H2.
    search.
    apply IH to H3 H4. case H5.
     search.
     search.

Theorem ctx2_uniform :
  forall G D X, nabla n,
  ctx2 (G n) (D n) ->
  member (pi u\ breduce X u => breduce n u) (G n) ->
  member (pi q\ path X q => path n q) (D n).
induction on 1. intros. case H1.
  case H2.
  case H2. apply IH to H3 H4. search.
  case H2. apply IH to H3 H4. search.
  case H2. apply IH to H3 H4. search.
  case H2. search. apply IH to H3 H4. search.

Theorem member_prune_D :
   forall G D E, nabla (n:tm),
   ctx2 G D ->
   member (E n) D -> exists F, E = x\ F.
induction on 1. intros. case H1.
  case H2.
  case H2. search. apply IH to H3 H4.
    apply IH to H3 H4. search.
  case H2. search. apply IH to H3 H4.
    apply IH to H3 H4. search.

Theorem member_D_determinate :
   forall G D X Y, nabla n,
   ctx2 (G n) (D n) ->
   member (pi q\ path X q => path n q) (D n) ->
   member (pi q\ path Y q => path n q) (D n) ->
   X = Y.
induction on 1. intros. case H1.
  case H2.
  case H2. case H3. apply IH to H4 H5 H6. search.
  case H2. case H3. apply IH to H4 H5 H6. search.
  case H2. case H3. apply IH to H4 H5 H6. search.
  case H2. case H3.
    search.
    apply member_prune_D to H4 H5.
    apply member_prune_D to H4 H5.

Theorem member_D_discrim :
   forall G D X P, nabla n,
   ctx2 (G n) (D n) ->
   member (pi q\ path X q => path n q) (D n) ->
   member (path n P) (D n) ->
   false.
induction on 1. intros. case H1.
  case H2.
  case H2. case H3. apply IH to H4 H5 H6.
  case H2. apply member_prune_D to H4 H5.
  case H2. case H3. apply IH to H4 H5 H6.
  case H3. apply member_prune_D to H4 H5.

Theorem jump_D_invert :
   forall G D X P, nabla n,
   ctx2 (G n) (D n) ->
   member (pi q\ path X q => path n q) (D n) ->
   { D n |- path n P } -> { D n |- path X P }.
intros. case H3.
apply ctx2_mem_D to H1 H5. case H6.
  case H4. apply member_D_discrim to H1 H2 H5.
  case H4. case H7. apply member_D_determinate to H1 H2 H5. search.

Theorem breduce_ltr :
  forall G D M N P,
  ctx2 G D ->
  { G |- breduce M N } ->
  { D |- path M P } -> { D |- path N P }.
induction on 2.
intros. case H2 (keep).
  case H3.
    apply IH to _ H4 H5. search.
    apply ctx2_mem_D to H1 H6. case H7.
      case H8. case H5.
      case H8. case H5.
  case H3.
    apply IH to _ H4 H6. search.
    apply IH to _ H5 H6. search.
    apply ctx2_mem_D to H1 H7. case H8.
      case H9. case H6.
      case H9. case H6.
  case H3.
    apply IH to _ H4 H5.
     inst H6 with n1 = N1.
     assert {D |- pi q\ path N1 q => path N1 q}.
     cut H7 with H8. search.
    apply ctx2_mem_D to H1 H6. case H7.
      case H8. case H5.
      case H8. case H5.
  apply ctx2_mem_G to H1 H5. case H6.
    case H7. case H4. search.
    case H7. case H4.
     assert {D n1 |- path X P}.
       apply ctx2_uniform to H1 H5.
       apply jump_D_invert to H1 H9 H3. search.
     apply IH to H1 H8 H9. search.

Theorem breduce_rtl :
  forall G D M N P,
  ctx2 G D ->
  { G |- breduce M N } ->
  { D |- path N P } -> { D |- path M P }.
induction on 2.
intros. case H2 (keep).
  case H3.
    apply IH to _ H4 H5. search.
    apply ctx2_mem_D to H1 H6. case H7.
      case H8. case H5.
      case H8. case H5.
  case H3.
    apply IH to _ H4 H6. search.
    apply IH to _ H5 H6. search.
    apply ctx2_mem_D to H1 H7. case H8.
      case H9. case H6.
      case H9. case H6.
  assert {D, (pi q\ path N1 q => path n1 q) |- path N P}.
   apply IH to _ H4 H5. search.
  apply ctx2_mem_G to H1 H5. case H6.
    case H7. case H4. search.
    case H7. case H4.
     apply IH to H1 H8 H3.
     apply ctx2_uniform to H1 H5. search.

Theorem closed_breduce_paths :
   forall M N P,
   {breduce M N} -> (   ({path M P} -> {path N P})
                  /\ ({path N P} -> {path M P})).
assert ctx2 nil nil. intros. split.
  intros. apply breduce_ltr to H1 H2 H3. search.
  intros. apply breduce_rtl to H1 H2 H3. search.

%Define bfctx : olist -> olist -> prop by
%  bfctx nil nil
%; nabla n p, bfctx (bfree n :: G) (path n p :: D) := bfctx G D.
%
%Theorem bfree_sames :
%  forall G D M N,
%  bpcx G D ->
%  {G |- bfree M} -> {G |- bfree N} ->
%  (forall p, {D |- path M p} -> {D |- path N p}) ->
%  M = N.
%induction on 2.
%skip. %% exercise
