%% Paths through lambda terms
%%
%% Here we prove: if all the paths in the lambda term X also exist in
%% the lambda term Y then X = Y.

Define ctxs nil nil.
Define nabla x, ctxs (tm x :: L) (path x x :: K) := ctxs L K.

Define nabla x, name x.

Theorem member_ctxs1 : forall E L K,
  ctxs L K -> member (tm E) L -> name E /\ member (path E E) K.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem member_ctxs2 : forall E F L K,
  ctxs L K -> member (path E F) K -> name E /\ E = F.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem path_app : forall L K M N Y,
  ctxs L K -> (forall P, {K |- path (app M N) P} -> {K |- path Y P}) ->
    exists YM YN, Y = app YM YN.
intros.
assert {K |- path (app M N) (fst done)}.
apply H2 to H3.
case H4.
  apply member_ctxs2 to H1 H5. case H6.
  search.
  
Theorem path_abs : forall L K R Y,
  ctxs L K -> (forall P, {K |- path (abs R) P} -> {K |- path Y P}) ->
    exists YR, Y = abs YR.
intros.
assert {K |- path (abs R) (bnd x\ done)}.
apply H2 to H3.
case H4.
  apply member_ctxs2 to H1 H5. case H6.
  search.

Theorem path_equal : forall L K X Y,
  ctxs L K -> {L |- tm X} ->
    (forall P, {K |- path X P} -> {K |- path Y P}) -> X = Y.
induction on 2. intros. case H2 (keep).

  % X is a variable
  apply member_ctxs1 to H1 H4.
  assert {K |- path X X}.
  apply H3 to H7.
  case H5. case H8.
  apply member_ctxs2 to H1 H9. search.

  % X = app M N
  apply path_app to H1 H3.

    % Apply the IH to M
    assert forall P, {K |- path M P} -> {K |- path YM P}.
      intros.
      assert {K |- path (app M N) (fst P)}.
      apply H3 to H7. case H8.
        apply member_ctxs2 to H1 H9.
        search.
    apply IH to H1 H4 H6.
      
    % Apply the IH to M
    assert forall P, {K |- path N P} -> {K |- path YN P}.
      intros.
      assert {K |- path (app M N) (snd P)}.
      apply H3 to H8. case H9.
        apply member_ctxs2 to H1 H10.
        search.
    apply IH to H1 H5 H7.

    % Finish this case
    search.

  % X = abs R
  apply path_abs to H1 H3.

    % Apply the IH to (R n1)
    assert forall P, {K, path n1 n1 |- path (R n1) P} ->
                     {K, path n1 n1 |- path (YR n1) P}.
      intros.
      assert {K |- path (abs R) (bnd P)}.
      apply H3 to H6. case H7.
        apply member_ctxs2 to H1 H8.
        search.
    assert ctxs (tm n1 :: L) (path n1 n1 :: K).
    apply IH to H6 H4 H5.

    % Finish this case
    search.
