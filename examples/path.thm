Define ctxs nil nil.
Define nabla x, ctxs (tm x :: L) (path x x :: K) := ctxs L K.

Define nabla x, name x.

Theorem member_ctxs1 : forall E L K,
  ctxs L K -> member (tm E) L -> name E /\ member (path E E) K.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem member_ctxs2 : forall E F L K,
  ctxs L K -> member (path E F) K -> name E /\ E = F.
induction on 1. intros. case H1.
  case H2.
  case H2.
    search.
    apply IH to H3 H4. search.

Theorem exists_path : forall L K X,
  ctxs L K -> {L |- tm X} -> exists P, {K |- path X P}.
induction on 2. intros. case H2.
  apply member_ctxs1 to H1 H3. search.
  apply IH to H1 H3. search.
  apply IH to _ H3. search.

Theorem path_app : forall L K M N Y,
  ctxs L K -> {L |- tm (app M N)} ->
    (forall P, {K |- path (app M N) P} -> {K |- path Y P}) ->
    exists YM YN, Y = app YM YN.
intros.
apply exists_path to H1 H2. apply H3 to H4. case H4.
  apply member_ctxs2 to H1 H6. case H7.
  case H5.
    apply member_ctxs2 to H1 H7. case H8.
    search.
  case H5.
    apply member_ctxs2 to H1 H7. case H8.
    search.

Theorem path_equal : forall L K X Y,
  ctxs L K -> {L |- tm X} ->
    (forall P, {K |- path X P} -> {K |- path Y P}) -> X = Y.
induction on 2. intros. case H2 (keep).

  % X is a variable
  apply member_ctxs1 to H1 H4.
  assert {K |- path X X}.
  apply H3 to H7.
  case H5. case H8.
  apply member_ctxs2 to H1 H9. search.

  % X = app M N
  apply path_app to H1 H2 _ with Y = Y.

  ..

  % X = app M N
  % first show Y must be an app
  apply exists_path to _ H1. apply H2 to H5. case H5.

  case H6.
  assert forall P, {path M P} -> {path M1 P}.
    intros.
    assert {path (app M N) (fst P2)}.
    apply H2 to H10. case H11. search.
  apply IH to H3 H9.
  assert forall P, {path N P} -> {path N1 P}.
    intros.
    assert {path (app M N) (snd P2)}.
    apply H2 to H11. case H12. search.
  apply IH to H4 H10.
  search.

  case H6.
  assert forall P, {path M P} -> {path M1 P}.
    intros.
    assert {path (app M N) (fst P2)}.
    apply H2 to H10. case H11. search.
  apply IH to H3 H9.
  assert forall P, {path N P} -> {path N1 P}.
    intros.
    assert {path (app M N) (snd P2)}.
    apply H2 to H11. case H12. search.
  apply IH to H4 H10.
  search.

  % X = abs R
  apply exists_path to _ H3.
  skip.
